<!DOCTYPE html>
<html lang="en">

<head>
    <title>WebGL 2 Samples - vertex_format</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="third-party/gl-matrix.js"></script>
</head>

<body>
    <div id="info">WebGL 2 Samples - vertex_format</div>

    <!-- WebGL 2 shaders -->
    <script id="vs" type="x-shader/x-vertex">
        #version 300 es
        #define POSITION_LOCATION 1
        #define TEXCOORD_LOCATION 2
        #define NORMAL_LOCATION 3
        #define COLOR_LOCATION 4

        precision highp float;
        precision highp int;

        uniform mat4 u_model;
        uniform mat4 u_modelInvTrans; // To properly transform normals to world space
        uniform mat4 u_viewProj;
        uniform vec3 u_lightPosition;

        layout(location = POSITION_LOCATION) in vec3 a_position;
        layout(location = TEXCOORD_LOCATION) in vec2 a_texCoord;
        layout(location = NORMAL_LOCATION) in vec3 a_normal;
        layout(location = COLOR_LOCATION) in vec4 a_color;

        // Vertex shader outputs to fragment shader
        out vec2 v_texCoord;
        out vec3 v_normal;
        out vec3 v_color;
        out vec3 v_lightDirection;

        void main()
        {
            // Compute position
            vec3 modelPosition = vec3(u_model * vec4(a_position, 1.0));
            v_lightDirection = u_lightPosition - modelPosition;
            gl_Position = u_viewProj * vec4(modelPosition, 1.0);

            v_normal = vec3(u_modelInvTrans * vec4(a_normal, 0.0));

            // Pass through
            v_color = a_color;
            v_texCoord = a_texCoord;
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        #version 300 es
        #define POSITION_LOCATION 1
        #define TEXCOORD_LOCATION 2
        #define NORMAL_LOCATION 3
        #define COLOR_LOCATION 4

        precision highp float;
        precision highp int;
        precision highp sampler2D;

        uniform sampler2D s_tex2D;
        uniform float ambient;

        in vec2 v_texCoord;
        in vec3 v_normal;
        in vec4 v_color;
        in vec3 v_lightDirection;

        out vec4 color;

        void main()
        {
            color = texture(s_tex2D, v_texCoord);

            float lightIntensity = dot(normalize(v_normal), normalize(v_lightDirection)) + ambient;

            color = color.rgb * lightIntensity;
        }

    </script>

    <script src="utility.js"></script>
    <script>
    (function () {
        'use strict';

        var canvas = document.createElement('canvas');
        canvas.width = Math.min(window.innerWidth, window.innerHeight);
        canvas.height = canvas.width;
        document.body.appendChild(canvas);

        var gl = canvas.getContext( 'webgl2', { antialias: false } );
        var isWebGL2 = !!gl;
        if(!isWebGL2) {
            document.getElementById('info').innerHTML = 'WebGL 2 is not available.  See <a href="https://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">How to get a WebGL 2 implementation</a>';
            return;
        }

        // -- Init program
        var program = createProgram(gl, getShaderSource('vs'), getShaderSource('fs'));
        var unifModel = gl.getUniformLocation(program, 'u_model');
        var unifViewProj = gl.getUniformLocation(program, 'u_viewProj');
        var unifTex2D = gl.getUniformLocation(program, 's_tex2D');

        var unifModel = gl.getUniformLocation(program, 'mvMatrix');
        var unifViewProj = gl.getUniformLocation(program, 'pMatrix');
        var unifTex2D = gl.getUniformLocation(program, 'diffuse');

        // -- Init geometries
        var cubeVertexArray;
        createCube(cubeVertexArray);


        // -- Init Texture

        var imageUrl = '../assets/img/Di-3d.png';
        var texture;
        loadImage(imageUrl, function(image) {
            // -- Init 2D Texture
            texture = gl.createTexture();
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            // -- Allocate storage for the texture
            gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGB8, 512, 512);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGB, gl.UNSIGNED_BYTE, image);

            requestAnimationFrame(render);

        });

        // -- Initialize render variables
        var orientation = [0.0, 0.0, 0.0];

        var modelMatrix = mat4.create([
            0.5, 0.0, 0.0, 0.0,
            0.0, 0.5, 0.0, 0.0,
            0.0, 0.0, 0.5, 0.0,
            0.0, 0.0, 0.0, 1.0
        ]);

        var mvMatrix = mat4.create();
        var translate = vec3.create();
        vec3.set(translate, 0, 0, -10);
        mat4.translate(mvMatrix, modelMatrix, translate);
        var perspectiveMatrix = mat4.create();
        mat4.perspective(perspectiveMatrix, 0.785, 1, 1, 1000);

        // -- Mouse Behaviour

        var mouseDown = false;
        var lastMouseX = 0;
        var lastMouseY = 0;

        canvas.onmousedown = function(event) {
            mouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        };

        canvas.onmouseup = function(event) {
            mouseDown = false;
        };

        canvas.onmousemove = function(event) {
            var newX = event.clientX;
            var newY = event.clientY;

            var deltaX = newX - lastMouseX;
            var deltaY = newY - lastMouseY;

            var m = mat4.create();

            mat4.rotateX(m, m, deltaX / 100.0);
            mat4.rotateY(m, m, deltaY / 100.0);

            var scale = vec3.create();
            vec3.set(scale, (1 + deltaX / 1000.0), (1 + deltaX / 1000.0), (1 + deltaX / 1000.0));
            mat4.scale(m, m, scale);

            mat4.multiply(mvMatrix, mvMatrix, m);

            lastMouseX = newX;
            lastMouseY = newY;
        };

        function createCube(vertexArray) {
            var positions = new Float32Array([
              // Front face
              -1.0, -1.0,  1.0,
               1.0, -1.0,  1.0,
               1.0,  1.0,  1.0,
              -1.0,  1.0,  1.0,

              // Back face
              -1.0, -1.0, -1.0,
              -1.0,  1.0, -1.0,
               1.0,  1.0, -1.0,
               1.0, -1.0, -1.0,

              // Top face
              -1.0,  1.0, -1.0,
              -1.0,  1.0,  1.0,
               1.0,  1.0,  1.0,
               1.0,  1.0, -1.0,

              // Bottom face
              -1.0, -1.0, -1.0,
               1.0, -1.0, -1.0,
               1.0, -1.0,  1.0,
              -1.0, -1.0,  1.0,

              // Right face
               1.0, -1.0, -1.0,
               1.0,  1.0, -1.0,
               1.0,  1.0,  1.0,
               1.0, -1.0,  1.0,

              // Left face
              -1.0, -1.0, -1.0,
              -1.0, -1.0,  1.0,
              -1.0,  1.0,  1.0,
              -1.0,  1.0, -1.0
            ]);
            var vertexPosBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            var texCoords = new Float32Array([
                // Front face
                0.0, 0.0,
                0.0, 1.0,
                1.0, 1.0,
                1.0, 0.0,

                // Back face
                1.0, 1.0,
                1.0, 0.0,
                0.0, 0.0,
                0.0, 1.0,

                // Top face
                0.0, 0.0,
                0.0, 1.0,
                1.0, 1.0,
                1.0, 0.0,

                // Bottom face
                0.0, 0.0,
                0.0, 1.0,
                1.0, 1.0,
                1.0, 0.0,

                // Right face
                0.0, 0.0,
                0.0, 1.0,
                1.0, 1.0,
                1.0, 0.0,

                // Left face
                0.0, 0.0,
                0.0, 1.0,
                1.0, 1.0,
                1.0, 0.0
            ]);
            var vertexTexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            // Element buffer
            var indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

            var cubeVertexIndices = [
              0,  1,  2,      0,  2,  3,    // front
              4,  5,  6,      4,  6,  7,    // back
              8,  9,  10,     8,  10, 11,   // top
              12, 13, 14,     12, 14, 15,   // bottom
              16, 17, 18,     16, 18, 19,   // right
              20, 21, 22,     20, 22, 23    // left
            ];

            // Now send the element array to GL

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);

            // -- Init VertexArray
            vertexArray = gl.createVertexArray();
            gl.bindVertexArray(vertexArray);

            var vertexPosLocation = 0; // set with GLSL layout qualifier
            gl.enableVertexAttribArray(vertexPosLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
            gl.vertexAttribPointer(vertexPosLocation, 3, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            var vertexTexLocation = 1; // set with GLSL layout qualifier
            gl.enableVertexAttribArray(vertexTexLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexBuffer);
            gl.vertexAttribPointer(vertexTexLocation, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

            gl.bindVertexArray(null);
        }

        function render() {
            // -- Render
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            gl.cullFace(gl.BACK);

            orientation[0] = 0.00020; // yaw
            orientation[1] = 0.00010; // pitch
            orientation[2] = 0.00005; // roll

            mat4.rotateX(mvMatrix, mvMatrix, orientation[0] * Math.PI);
            mat4.rotateY(mvMatrix, mvMatrix, orientation[1] * Math.PI);
            mat4.rotateZ(mvMatrix, mvMatrix, orientation[2] * Math.PI);

            gl.bindVertexArray(cubeVertexArray);
            gl.useProgram(program);
            gl.uniformMatrix4fv(unifModel, false, mvMatrix);
            gl.uniformMatrix4fv(unifViewProj, false, perspectiveMatrix);
            gl.uniform1i(unifTex2D, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.drawElementsInstanced(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0, 1);

            requestAnimationFrame(render);
        }

        document.onunload = function() {
            // Delete WebGL resources
            gl.deleteBuffer(vertexPosBuffer);
            gl.deleteBuffer(vertexTexBuffer);
            gl.deleteBuffer(indexBuffer);
            gl.deleteTexture(texture);
            gl.deleteProgram(program);
            gl.deleteVertexArray(vertexArray);

        };
    })();
    </script>

</body>

</html>
