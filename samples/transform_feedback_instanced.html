<!DOCTYPE html>

<html lang="en">

<head>
    <title>WebGL 2 Samples - transform_feedback_instanced</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="utility.js"></script>
    <script src="third-party/gl-matrix-min.js"></script>
    <script src="third-party/noise3D.js"></script>
</head>

<body>
    <div id="info">WebGL 2 Samples - transform_feedback_instanced</div>
    <p id="description">Demonstrates how to combine transform feedback and instanced drawing</p>

    <!-- WebGL 2 shaders -->
    <script id="vs-emit" type="x-shader/x-vertex">
        #version 300 es
        #define POSITION_LOCATION 0
        #define SIN2 0.06975647
        #define COS2 0.99756405

        precision highp float;
        precision highp int;


        layout(location = POSITION_LOCATION) in vec2 a_position;

        out vec2 v_position;

        void main()
        {
            mat2 rotation = mat2(
                COS2, SIN2,
                -SIN2, COS2
            );
            
            v_position = rotation * a_position;
            gl_Position = vec4(v_position, 0.0, 1.0);
        }
    </script>

    <!-- Unsused -->
    <script id="fs-emit" type="x-shader/x-fragment">
        #version 300 es
        precision highp float;
        precision highp int;

        void main()
        {
        }
    </script>

    <script id="vs-draw" type="x-shader/x-vertex">
        #version 300 es
        #define POSITION_LOCATION 0
        #define OFFSET_LOCATION 1
        #define COLOR_LOCATION 2

        precision highp float;
        precision highp int;

        layout(location = POSITION_LOCATION) in vec2 a_position;
        layout(location = OFFSET_LOCATION) in vec2 a_offset;
        layout(location = COLOR_LOCATION) in vec3 a_color;

        out vec3 v_color;

        void main()
        {
            v_color = a_color;
            gl_Position = vec4(a_position + a_offset, 0.0, 1.0);
        }
    </script>

    <script id="fs-draw" type="x-shader/x-fragment">
        #version 300 es
        #define ALPHA 0.9

        precision highp float;
        precision highp int;

        in vec3 v_color;

        out vec4 color;

        void main()
        {
            color = vec4(v_color * ALPHA, ALPHA);
        }
    </script>

    <script>
    (function () {
        'use strict';

        // -- Init Canvas
        var canvas = document.createElement('canvas');
        canvas.width = Math.min(window.innerWidth, window.innerHeight);
        canvas.height = canvas.width;
        document.body.appendChild(canvas);

        // -- Init WebGL Context
        var gl = canvas.getContext('webgl2', { antialias: false });
        var isWebGL2 = !!gl;
        if(!isWebGL2)
        {
            document.getElementById('info').innerHTML = 'WebGL 2 is not available.  See <a href="https://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">How to get a WebGL 2 implementation</a>';
            return;
        }

        canvas.addEventListener("webglcontextlost", function(event) {
            event.preventDefault();
        }, false);

        // -- Declare variables for the particle system
        var NUM_INSTANCES =3000;

        var appStartTime = Date.now();
        var currentSourceIdx = 0;

        // -- Init Program

        var PROGRAM_TRANSFORM = 0;
        var PROGRAM_DRAW = 1;

        var programs = initPrograms();

        // -- Initialize data

        var tranglePositions = new Float32Array([
            -0.013, -0.013, 
            0.013, -0.013, 
            0.0, 0.013,
        ]);

        var instanceOffsets = new Float32Array(NUM_INSTANCES * 2);
        var instanceColors = new Float32Array(NUM_INSTANCES * 3)

        for (var i = 0; i < NUM_INSTANCES; ++i) {
            var oi = i * 2;
            var ci = i * 3;

            instanceOffsets[oi] = Math.random() * 2.0 - 1.0;
            instanceOffsets[oi + 1] = Math.random() * 2.0 - 1.0;

            instanceColors[ci] = Math.random();
            instanceColors[ci + 1] = Math.random();
            instanceColors[ci + 2] = Math.random();
        }

        // -- Init Vertex Array
        var POSITION_LOCATION = 0;
        var OFFSET_LOCATION = 1;
        var COLOR_LOCATION = 2;
        var NUM_LOCATIONS = 3;

        var vertexArrays = [gl.createVertexArray(), gl.createVertexArray()];

        var vertexBuffers = new Array(vertexArrays.length);

        for (var i = 0; i < vertexArrays.length; ++i) {
            gl.bindVertexArray(vertexArrays[i]);
            vertexBuffers[i] = new Array(NUM_LOCATIONS);
           
            vertexBuffers[i][POSITION_LOCATION] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffers[i][POSITION_LOCATION]);
            gl.bufferData(gl.ARRAY_BUFFER, tranglePositions, gl.STREAM_COPY);            
            gl.vertexAttribPointer(POSITION_LOCATION, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(POSITION_LOCATION);

            vertexBuffers[i][OFFSET_LOCATION] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffers[i][OFFSET_LOCATION]);
            gl.bufferData(gl.ARRAY_BUFFER, instanceOffsets, gl.STATIC_DRAW);
            gl.vertexAttribPointer(OFFSET_LOCATION, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(OFFSET_LOCATION);
            gl.vertexAttribDivisor(OFFSET_LOCATION, 1); // attribute used once per instance

            vertexBuffers[i][COLOR_LOCATION] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffers[i][COLOR_LOCATION]);
            gl.bufferData(gl.ARRAY_BUFFER, instanceColors, gl.STATIC_DRAW);
            gl.vertexAttribPointer(COLOR_LOCATION, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(COLOR_LOCATION);
            gl.vertexAttribDivisor(COLOR_LOCATION, 1); // attribute used once per instance

            gl.bindVertexArray(null);
        }

        // -- Init TransformFeedback
        var transformFeedback = gl.createTransformFeedback();

        render();

        function initPrograms() {

            // Setup program for transform feedback shaders
            function createShader(gl, source, type) {
                var shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                return shader;
            }

            var vshaderTransform = createShader(gl, getShaderSource('vs-emit'), gl.VERTEX_SHADER);
            var fshaderTransform = createShader(gl, getShaderSource('fs-emit'), gl.FRAGMENT_SHADER);

            var programTransform = gl.createProgram();
            gl.attachShader(programTransform, vshaderTransform);
            gl.deleteShader(vshaderTransform);
            gl.attachShader(programTransform, fshaderTransform);
            gl.deleteShader(fshaderTransform);

            var varyings = ['v_position'];
            gl.transformFeedbackVaryings(programTransform, varyings, gl.SEPARATE_ATTRIBS);
            gl.linkProgram(programTransform);

            // check
            var log = gl.getProgramInfoLog(programTransform);
            if (log) {
                console.log(log);
            }

            log = gl.getShaderInfoLog(vshaderTransform);
            if (log) {
                console.log(log);
            }

            // Setup program for draw shader
            var programDraw = createProgram(gl, getShaderSource('vs-draw'), getShaderSource('fs-draw'));

            var programs = [programTransform, programDraw];
            return programs;
        }

        function transform() {
            var time = Date.now() - appStartTime;

            var programTransform = programs[PROGRAM_TRANSFORM];

            // Toggle source and destination VBO
            var sourceVBO = vertexBuffers[currentSourceIdx];
            var sourceVAO = vertexArrays[currentSourceIdx];

            var destinationVBO = vertexBuffers[(currentSourceIdx + 1) % 2];

            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);

            gl.useProgram(programTransform);

            gl.bindVertexArray(sourceVAO);

            // Set transform feedback buffer
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, destinationVBO[POSITION_LOCATION]);

            // Turn off rasterization - we are not drawing
            gl.enable(gl.RASTERIZER_DISCARD);

            // Rotate triangles using transform feedback
            gl.beginTransformFeedback(gl.TRIANGLES);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            gl.endTransformFeedback();

            // Restore state
            gl.disable(gl.RASTERIZER_DISCARD);
            gl.useProgram(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

            // Ping pong the buffers
            currentSourceIdx = (currentSourceIdx + 1) % 2;
        }

        function render() {
            // Rotate triangles
            transform();

            // Set the viewport
            gl.viewport(0, 0, canvas.width, canvas.height - 10);

            // Clear color buffer
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.bindVertexArray(vertexArrays[currentSourceIdx]);

            gl.useProgram(programs[PROGRAM_DRAW]);

            // Enable blending
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

            gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, NUM_INSTANCES);

            requestAnimationFrame(render);
        }

        // If you have a long-running page, and need to delete WebGL resources, use:
        //
        // gl.deleteTransformFeedback(transformFeedback);
        // gl.deleteProgram(programs[PROGRAM_TRANSFORM]);
        // gl.deleteProgram(programs[PROGRAM_DRAW]);
        // for (var i = 0; i < 2; ++i) {
        //     for (var j = 0; j < Particle.MAX; ++j) {
        //         gl.deleteBuffer(vertexBuffers[i][j]);
        //     }
        // }
        // gl.deleteVertexArray(vertexArrays[PROGRAM_TRANSFORM]);
        // gl.deleteVertexArray(vertexArrays[PROGRAM_DRAW]);
    })();
    </script>
    <div id="highlightedLines"  style="display: none">#L173-L294</div>

</body>

</html>
