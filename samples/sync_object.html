<!DOCTYPE html>
<!-- Adapted from the OpenGL ES 3.0: Programming Guide, Second Edition, Dan Ginsburg and Budirijanto Purnomo https://github.com/danginsburg/opengles3-book/blob/master/Chapter_14/ParticleSystemTransformFeedback/ParticleSystemTransformFeedback.c -->

<html lang="en">

<head>
    <title>WebGL 2 Samples - sync_object</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="utility.js"></script>
    <script src="third-party/gl-matrix.js"></script>
    <script src="third-party/noise3D.js"></script>
</head>

<body>
    <div id="info">WebGL 2 Samples - sync_object</div>
    <p id="description">
</p>

    <!-- WebGL 2 shaders -->
    <script id="vs-emit" type="x-shader/x-vertex">
        #version 300 es
        #define POSITION_LOCATION 0
        #define VELOCITY_LOCATION 1
        #define SPAWNTIME_LOCATION 2
        #define LIFETIME_LOCATION 3
        #define ID_LOCATION 4

        precision highp float;
        precision highp int;
        precision highp sampler3D;

        uniform float u_time;
        uniform float u_emissionRate;
        uniform vec2 u_acceleration;
        uniform sampler3D s_noiseTex;

        layout(location = POSITION_LOCATION) in vec2 a_position;
        layout(location = VELOCITY_LOCATION) in vec2 a_velocity;
        layout(location = SPAWNTIME_LOCATION) in float a_spawntime;
        layout(location = LIFETIME_LOCATION) in float a_lifetime;
        layout(location = ID_LOCATION) in float a_ID;

        out vec2 v_position;
        out vec2 v_velocity;
        out float v_spawntime;
        out float v_lifetime;

        float rand(vec2 co){
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main()
        {
            float deltaTime = u_time - a_spawntime;
            if (deltaTime > a_lifetime) {
                // Generate a new particle
                v_position = a_position;//vec2(rand(vec2(a_ID, a_ID)), rand(vec2(a_ID, a_ID)));
                v_velocity = vec2(rand(vec2(a_ID, 0.0)), rand(vec2(a_ID, a_ID)));
                v_spawntime = u_time;
                v_lifetime = 2.0;
            } else {
                v_velocity = a_velocity + 0.01 * u_acceleration;
                v_position = a_position + 0.01 * v_velocity;
                v_spawntime = a_spawntime;
                v_lifetime = a_lifetime;
            }

        }
    </script>

    <!-- Unsused -->
    <script id="fs-emit" type="x-shader/x-fragment">
        #version 300 es
        precision highp float;
        precision highp int;

        out vec4 color;

        void main()
        {
            color = vec4(1.0);
        }
    </script>

    <script id="vs-draw" type="x-shader/x-vertex">
        #version 300 es
        #define POSITION_LOCATION 0
        #define VELOCITY_LOCATION 1
        #define SPAWNTIME_LOCATION 2
        #define LIFETIME_LOCATION 3

        precision highp float;
        precision highp int;

        uniform float u_time;
        uniform vec2 u_acceleration;

        out vec2 v_position;
        out vec2 v_velocity;
        out float v_spawntime;
        out float v_lifetime;

        layout(location = POSITION_LOCATION) in vec2 a_position;
        layout(location = VELOCITY_LOCATION) in vec2 a_velocity;
        layout(location = SPAWNTIME_LOCATION) in float a_spawntime;
        layout(location = LIFETIME_LOCATION) in float a_lifetime;

        void main()
        {
            float deltaTime = u_time - a_spawntime;
            if (deltaTime <= a_lifetime) {
                gl_Position = vec4(a_position, 0.0, 1.0);
            } else {
                gl_Position = vec4(0, 0, 0, 1);
            }
            gl_PointSize = 5.0;
        }
    </script>

    <script id="fs-draw" type="x-shader/x-fragment">
        #version 300 es
        precision highp float;
        precision highp int;

        uniform vec4 u_color;

        out vec4 color;

        void main()
        {
            color = u_color;
        }
    </script>

    <script>
    (function () {
        'use strict';

        // -- Init Canvas
        var canvas = document.createElement('canvas');
        canvas.width = Math.min(window.innerWidth, window.innerHeight);
        canvas.height = canvas.width;
        document.body.appendChild(canvas);

        // -- Init WebGL Context
        var gl = canvas.getContext('webgl2', { antialias: false });
        var isWebGL2 = !!gl;
        if(!isWebGL2)
        {
            document.getElementById('info').innerHTML = 'WebGL 2 is not available.  See <a href="https://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">How to get a WebGL 2 implementation</a>';
            return;
        }

        canvas.addEventListener("webglcontextlost", function(event) {
            event.preventDefault();
        }, false);

        // -- Declare variables for the particle system

        var EMISSION_RATE = 0.3;
        var NUM_PARTICLES = 200;
        var ACCELERATION = -1.0;

        var time = Date.now();
        var currentSourceIdx = 0;
        var emitSync;

        // -- Init Program

        var PROGRAM_EMIT = 0;
        var PROGRAM_DRAW = 1;

        var programs = initPrograms();

        // Get uniform locations for the transform feedback program
        var emitTimeLocation = gl.getUniformLocation(programs[PROGRAM_EMIT], 'u_time');
        var emitEmissionRateLocation = gl.getUniformLocation(programs[PROGRAM_EMIT], 'u_emissionRate');
        var emitNoiseSamplerLocation = gl.getUniformLocation(programs[PROGRAM_EMIT], 's_noiseTex');
        var emitAccelerationLocation = gl.getUniformLocation(programs[PROGRAM_EMIT], 'u_acceleration');

        // Get uniform locations for the draw program
        var drawTimeLocation = gl.getUniformLocation(programs[PROGRAM_DRAW], 'u_time');
        var drawAccelerationLocation = gl.getUniformLocation(programs[PROGRAM_DRAW], 'u_acceleration');
        var drawColorLocation = gl.getUniformLocation(programs[PROGRAM_DRAW], 'u_color');

        // -- Initialize particle data

        var particlePositions = new Float32Array(NUM_PARTICLES * 2);
        var particleVelocities = new Float32Array(NUM_PARTICLES * 2);
        var particleSpawntime = new Float32Array(NUM_PARTICLES);
        var particleLifetime = new Float32Array(NUM_PARTICLES);
        var particleIDs = new Float32Array(NUM_PARTICLES);

        var Particle = {
            POSITION: 0,
            VELOCITY: 1,
            SPAWN_TIME: 2,
            LIFE_TIME: 3,
            ID: 4,
            MAX: 5
        };

        for (var i = 0; i < NUM_PARTICLES; ++i) {
            particlePositions[i * 2] = 0.0;
            particlePositions[i * 2 + 1] = 0.0;
            particleVelocities[i * 2] = 0.0;
            particleVelocities[i * 2 + 1] = 0.0;
            particleSpawntime[i] = 0.0;
            particleLifetime[i] = 0.0;
            particleIDs[i] = i;
        }

        // -- Init Buffer

        var particleVBOs = new Array(2);

        for (var i = 0; i < 2; ++i) {
            particleVBOs[i] = new Array(Particle.MAX);
            for (var j = 0; j < Particle.MAX; ++j) {
                particleVBOs[i][j] = gl.createBuffer();
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, particleVBOs[i][Particle.POSITION]);
            gl.bufferData(gl.ARRAY_BUFFER, particlePositions, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, particleVBOs[i][Particle.VELOCITY]);
            gl.bufferData(gl.ARRAY_BUFFER, particleVelocities, gl.DYNAMIC_COPY);

            gl.bindBuffer(gl.ARRAY_BUFFER, particleVBOs[i][Particle.SPAWN_TIME]);
            gl.bufferData(gl.ARRAY_BUFFER, particleSpawntime, gl.DYNAMIC_COPY);

            gl.bindBuffer(gl.ARRAY_BUFFER, particleVBOs[i][Particle.LIFE_TIME]);
            gl.bufferData(gl.ARRAY_BUFFER, particleLifetime, gl.DYNAMIC_COPY);

            gl.bindBuffer(gl.ARRAY_BUFFER, particleVBOs[i][Particle.ID]);
            gl.bufferData(gl.ARRAY_BUFFER, particleIDs, gl.STATIC_DRAW);
        }

        // -- Init Vertex Array
        var particleVAOs = [gl.createVertexArray(), gl.createVertexArray()];

        var POSITION_LOCATION = 0;
        var VELOCITY_LOCATION = 1;
        var SPAWNTIME_LOCATION = 2;
        var LIFETIME_LOCATION = 3;
        var ID_LOCATION = 4;

        // -- Init TransformFeedback
        var transformFeedback = gl.createTransformFeedback();

        // -- Initialize 3d noise texture

        var SIZE = 32;
        var data = new Float32Array(SIZE * SIZE * SIZE);
        for (var k = 0; k < SIZE; ++k) {
            for (var j = 0; j < SIZE; ++j) {
                for (var i = 0; i < SIZE; ++i) {
                    data[i + j * SIZE + k * SIZE * SIZE] = snoise([i, j, k]);
                }
            }
        }

        var texture3D = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_3D, texture3D);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_BASE_LEVEL, 0);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAX_LEVEL, Math.log2(SIZE));
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        gl.texImage3D(
            gl.TEXTURE_3D,  // target
            0,              // level
            gl.R32F,        // internalformat
            SIZE,           // width
            SIZE,           // height
            SIZE,           // depth
            0,              // border
            gl.RED,         // format
            gl.FLOAT,       // type
            data            // pixel
            );

        gl.bindTexture(gl.TEXTURE_3D, null);

        render();

        function initPrograms() {
            var programEmit = (function(gl, vertexShaderSourceTransform, fragmentShaderSourceTransform) {
                function createShader(gl, source, type) {
                    var shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    return shader;
                }

                var vshaderTransform = createShader(gl, vertexShaderSourceTransform, gl.VERTEX_SHADER);
                var fshaderTransform = createShader(gl, fragmentShaderSourceTransform, gl.FRAGMENT_SHADER);

                var programEmit = gl.createProgram();
                gl.attachShader(programEmit, vshaderTransform);
                gl.deleteShader(vshaderTransform);
                gl.attachShader(programEmit, fshaderTransform);
                gl.deleteShader(fshaderTransform);

                // Is only limited to 4 varyings?
                var varyings = ['v_position', 'v_velocity', 'v_spawntime', 'v_lifetime'];
                gl.transformFeedbackVaryings(programEmit, varyings, gl.SEPARATE_ATTRIBS);
                gl.linkProgram(programEmit);

                // check
                var log = gl.getProgramInfoLog(programEmit);
                if (log) {
                    console.log(log);
                }

                log = gl.getShaderInfoLog(vshaderTransform);
                if (log) {
                    console.log(log);
                }

                return programEmit;
            })(gl, getShaderSource('vs-emit'), getShaderSource('fs-emit'));

            var programDraw = createProgram(gl, getShaderSource('vs-draw'), getShaderSource('fs-draw'));

            var programs = [programEmit, programDraw];
            return programs;
        }

        function setupVertexAttributes(vaoId, vboArray) {
            gl.bindVertexArray(vaoId);

            gl.bindBuffer(gl.ARRAY_BUFFER, vboArray[Particle.POSITION]);
            gl.vertexAttribPointer(POSITION_LOCATION, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, vboArray[Particle.VELOCITY]);
            gl.vertexAttribPointer(VELOCITY_LOCATION, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, vboArray[Particle.SPAWN_TIME]);
            gl.vertexAttribPointer(SPAWNTIME_LOCATION, 1, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, vboArray[Particle.LIFE_TIME]);
            gl.vertexAttribPointer(LIFETIME_LOCATION, 1, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, vboArray[Particle.ID]);
            gl.vertexAttribPointer(ID_LOCATION, 1, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(POSITION_LOCATION);
            gl.enableVertexAttribArray(VELOCITY_LOCATION);
            gl.enableVertexAttribArray(SPAWNTIME_LOCATION);
            gl.enableVertexAttribArray(LIFETIME_LOCATION);
            gl.enableVertexAttribArray(ID_LOCATION);
        }

        function emitParticles() {

            time = Date.now();

            var programEmit = programs[PROGRAM_EMIT];

            // Toggle source and destination VBO
            var sourceVBO = particleVBOs[currentSourceIdx];
            var destinationVBO = particleVBOs[(currentSourceIdx + 1) % 2];

            var sourceVAO = particleVAOs[currentSourceIdx];
            var destinationVAO = particleVAOs[(currentSourceIdx + 1) % 2];

            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);

            gl.useProgram(programEmit);

            setupVertexAttributes(sourceVAO, sourceVBO);

            // Set transform feedback buffer
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, destinationVBO[Particle.POSITION]);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, destinationVBO[Particle.VELOCITY]);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 2, destinationVBO[Particle.SPAWN_TIME]);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 3, destinationVBO[Particle.LIFE_TIME]);

            // Turn off rasterization - we are not drawing
            gl.enable(gl.RASTERIZER_DISCARD);

            // Set uniforms
            gl.uniform1f(emitTimeLocation, time);
            gl.uniform1f(emitEmissionRateLocation, EMISSION_RATE);
            gl.uniform2f(emitAccelerationLocation, 0.0, ACCELERATION);

            // Bind 3D noise texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_3D, texture3D);
            gl.uniform1i(emitNoiseSamplerLocation, 0);

            // Emit particles using transform feedback
            gl.beginTransformFeedback(gl.POINTS);
            gl.drawArrays(gl.POINTS, 0, NUM_PARTICLES);
            gl.endTransformFeedback();

            // Create a sync object to ensure transform feedback results
            // are completed before the draw that uses them.
            // Sync object can't be reused so we create a new one for each synchronization operation.
            // Not recommended to use gl.finish unless neccessary for synchronizing all your operation as it could severely reduce the GPU performance. Instead use sync object as you can wait for partial completion of the GL command stream.
            emitSync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);

            // Restore state
            gl.disable(gl.RASTERIZER_DISCARD);
            gl.useProgram(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindTexture(gl.TEXTURE_3D, null);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, null);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 2, null);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 3, null);
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);


            // Ping pong the buffers
            currentSourceIdx = (currentSourceIdx + 1) % 2;
        }


        // -- Initialize render variables
        var orientation = [0.0, 0.0, 0.0];

        var modelMatrix = mat4.create([
            0.5, 0.0, 0.0, 0.0,
            0.0, 0.5, 0.0, 0.0,
            0.0, 0.0, 0.5, 0.0,
            0.0, 0.0, 0.0, 1.0
        ]);

        var viewMatrix = mat4.lookAt(
            [4, 3, 300],
            [0, 0, 0],
            [0, 1, 0]
            );

        var mvMatrix = new Float32Array(mat4.multiply(viewMatrix, modelMatrix));
        var perspectiveMatrix = new Float32Array(mat4.perspective(0.45, 1, 1, 1000.0));

        function render() {

            // Spawn particle
            emitParticles();

            time = Date.now();

            // Block the GL server until transform feedback results are completed
            gl.waitSync(emitSync, 0, gl.TIMEOUT_IGNORED);

            // gl.deleteSync() does not occur immediately as the sync object will
            // be deleted when no other command operation is waiting for it.
            // Therefore it's safe to call deleteSync() here.
            gl.deleteSync(emitSync);

            // Set the viewport
            gl.viewport(0, 0, canvas.width, canvas.height - 10);

            // Clear color buffer
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            setupVertexAttributes(particleVAOs[currentSourceIdx], particleVBOs[currentSourceIdx]);

            gl.useProgram(programs[PROGRAM_DRAW]);

            // Set uniforms
            gl.uniform1f(drawTimeLocation, time);
            gl.uniform4f(drawColorLocation, 0.0, 1.0, 1.0, 1.0);
            gl.uniform2f(drawAccelerationLocation, 0.0, ACCELERATION);

            // Enable blending
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

            gl.drawArrays(gl.POINTS, 0, NUM_PARTICLES);

            requestAnimationFrame(render);
        }

        window.onunload = function() {
            // -- Delete WebGL resources
            gl.deleteTransformFeedback(transformFeedback);
            gl.deleteProgram(programs[PROGRAM_EMIT]);
            gl.deleteProgram(programs[PROGRAM_DRAW]);
            for (var i = 0; i < 2; ++i) {
                for (var j = 0; j < Particle.MAX; ++j) {
                    gl.deleteBuffer(particleVBOs[i][j]);
                }
            }
            gl.deleteVertexArray(particleVAOs[PROGRAM_EMIT]);
            gl.deleteVertexArray(particleVAOs[PROGRAM_DRAW]);
        }
    })();
    </script>

</body>

</html>
